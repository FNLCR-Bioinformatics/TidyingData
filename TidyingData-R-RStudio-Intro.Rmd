---
title: "BTEP-R-RStudio-Intro"
author: "Drs. Sarangan Ravichandran and Randall Johnson"
date: "February 26, 2017"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "H:/2017/BTEP1-TidyingData")
```

Let us first load the libraries
```{r loadlibraries}
# if you dont have tidyverse then run the following line once 
# install.packages("tidyverse")
library(tidyverse) 
```

## Let us introduce R/R-Studio Data Import with a Import Dataset and Command-line options


![](Images/RS-ImportDataset.png)


The following few lines will explain how to read in a data file via R command-line

Please note that we will be using **readr** function for this section. 
Note that read_csv is different than read.csv 

- read_csv(), read_csv2()  # read_csv2 and read_csv are same except for what options are default
- the returning objects from read_csv and read.csv are different (DF vs tibbles)
- read_tsv() 
- read_delim()

## Let us do some examples


Watch out how the column names are displayed and additional information 
that you get from read_csv
Also note the number of rows are displayed in read_csv compared to read.csv

```{r, echo = TRUE}
(tcsv <- read.csv("Data/WHO-2a.csv"))  # traditional csv object
(ncsv <- read_csv("Data/WHO-2a.csv"))  # new csv, tibble object

```

See the difference in the returning objects' class

```{r}
class(ncsv) # traditional csv function, read.csv 
class(tcsv) # tidyverse read_csv
```

What happens if your dataset has a metadata (indicated by \# ) as the first line followed by the column names

```{r}
read_csv("Data/WHO-2a.csv", comment = "#")
```

## Why we insist on using readr::read_csv than read.csv?

- Speed (~ 10x)
- output from readr is Tibbles (we talked about earlier)
- Base R taps into OS where it is executed. But readr functions are OS independent and
  hence reproducible
  
## Import Exercise-1

What function would you use to read a file whose fields are separated by \|

## To find out where you are, use the getwd command 

```{r}
getwd()
```

you can set a directory to go to by 
```{r, eval = FALSE}
setwd("YOUR_DIR"")
```



## To get a detailed description of the attached packages and R session 

```{r}
sessionInfo()
```



Basic Usage

```{r}
summary(cars)
```

If you want to just display the code chunk but not the concerned R code, 
you need "echo = FALSE" 
```{r, echo=FALSE}
summary(cars)
```

Plotting in Rmd. If you want the users to see the plot but not the code,
then do the following:

Note the eval=FALSE (upper case; lower case will fail)
```{r, echo=FALSE}
plot(cars)
```

If you want to display the R code without evualating, then use
```{r, eval=FALSE}
summary(cars)
```

What about additional formating when displaying the contens of a table? 
Note the **asis** option
```{r, results='asis'}
knitr::kable(mtcars)
```

In the tidyverse the commonly returning objects are not data.frame but tibbles.
So, let us introduce tibble in the next section 

## Tibble

What is tibble?

- modern way or loooking at the traditional data.frame 
- you will get a lot more useful information than the data.frames
- tibble is part of tibble package and part of the core tidyverse package
 
To get help, use 
```{r, tibblehelp, eval=FALSE}
?tibble
vignette("tibble")

```

 
How to create a tibble? 
```{r create-tibble}
tibble(
  x = 1:5, 
  y = LETTERS[1:5], 
  z = x^2 + 20
)

```
What is the difference between the R regular data.frame and 
tibble (data_frame)?

```{r TibblevsDataframe}
employee <- c('John Wayne','Peter Doe','Esther Julie')
salary <- c(20000, 23400, 26800)
startdate <- as.Date(c('2016-12-1','2007-3-25','2016-3-14'))
df <- data.frame(employee, salary, startdate)
df

as_tibble(df)

```

Let us create a data.frame and a tibble. 

```{r}
df1 <- data.frame( Color = "Red")
tb1 <-tibble(Color = "Red")
```

## Exercise: 

If you type the following commmands, what will you get and 
explain your reasoning:

```{r}
df1$C
tb1$C

class(df1$Color)
class(tb1$Color)
```

Also, speculate on the type of object that you will get from 
each of these above two operations? 

The above explains traditional R data.frame is helpful in 
filling in the missing information. Also how data.frame modifies
the variable type without asking (ex Character to Factor)


## Where can this go?

purr::map_dbl(mtcars, mean)
purrr:map_dbl(mtcars, mean)

tb1 <- as.tibble( Color = "red")
tb1$C  


you can coerce regular R data frame into tibble. Let us look at the R dataset, cars.
Let us learn about cars datset 

<pre> <code>
  ?cars
</code></pre>

Let us find out what class cars object belongs to and how to convert cars data frame into
tibbles object. Note that 

```{r coerce-tibble}
class(cars)
as_tibble(cars)
head(cars) #otherwise you get all 50 rows
```

## Why Tibble? 

- Tibble doesnt change the inputs. Ex. strings to factors 
- Doesnt add new names or modify the inputs
- For example, Tibble never converts strings to factors

## What is tribble

- transposed tibble, tribble()
- small data in readable form
- column headings are shown as formulas ( ie ~ )
- nice format
- no need to explicitely use head command (Ex. head cars)


```{r}
tribble(
  ~x, ~y, ~z,
  #--|--|----
  "Male", 187, 210,
  "Female", 190, 150
)
```

Let us create a little bit complicated tibble 
note that lubridate gives the current time

```{r complicatedtibble, results= 'asis'}
t2 <- tibble(
  a = lubridate::now() + runif(1e3) * 86400,
  b = lubridate::today() + runif(1e3) * 30,
  c = 1:1e3,
  d = runif(1e3),
  e = sample(letters, 1e3, replace = TRUE)
)
```


```{r}
t2
```

You can change the defaults of tibble display with options.

```{r}
options(tibble.print_max = 10, tibble.print_min = 6)
t2
```

You can also use the following tibble option to show all columns
```{r, eval=FALSE}
options(tibble.width = Inf)
# more options available at 
package?tibble
```


How to extract the columns or rows of tibble?

```{r}
head(t2$a)

has_name(t2, "b")
getOption("tibble.max_extra_cols")
```

how to add a row of a tibble in a specific place?

original t2 
```{r}
t2
```

```{r ,results='as.is'}
    aa = lubridate::today()
    bb = lubridate::now()
    cc = 1:1
    dd = runif(1)
    ee = sample(letters, 1, replace = TRUE)
    print(aa); print(bb); print(cc); print(dd); print(ee)
t2 %>% 
  add_row(
    a = aa, 
    b = bb,
    c = cc,
    d = dd,
    e = ee, .before = 2  # note the dot in ".before = 2"
)

```
After the change

```{r}
t2
```

## Subsetting 

- \$ by name
-    

```{r}

df <- tibble(
  x = runif(5),
  y = rnorm(5)
)

df$x

df[[1]]
```

Can you use Tibble in a pipeline?

```{r}
df %>% .$x   

df %>% .[["y"]]
```

What happens if tibble doesnt work with a package? 
Transform Tibble back to a data.frame using the following command:
```{r}
as.data.frame(df)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


```{r cars, fig.cap = "cars"}
with(cars, plot(speed,dist))
```

## Tibble Exercise 1

Create a new tibble with the following information:
  name, age, height, weight, smoker (T or F), Male (True or Fale)
 compare the tibble with the R data_frame


## Exercise 2

convert iris data set (given to us in data.frame ) to tibble data_frame


## Exercise 3

How can you tell whether the object is a Tibble or not? 

## Exercise 4 (based on Wickam's book)

Partial matching is a big issue with data.frame.
df <- data.frame(abc = 1, xyz = "a")
df$x
df[, "xyz"]


## R 

- R is a Dynamic programming language
- Different from other languages such as C, modern Fortran, Java
- Require compilation 

## Availability 

- Base R and R core packages can be downloaded from 
- Comprehensive R Archive Network (CRAN)
- Available in Windows/Linux/Mac0
- cran.r-project.org 

- How to interact with R? 
- RGUI Deducer (preferred for the class) or RStudio 

## Installing/Using a package in R

- R comes with core packages (basic). There are several 
  packages available for R (Ex. Tidyverse)
  
- How can I install a package? 

<code>  install.packages("foreign")  # to install foreign package </code>

- After installation, you have load the package, using the following command
<pre> <code> 
library(foreign) 
help(package=foreign)
</code> </pre>

After using a package, you can <pre> detach(foreign) </pre> to remove a package from the 
workspace.

Use <pre> SessionInfo() </pre> to get a detailed description of the attached packages and R session

#R commands can be either typed or loaded from a file
# using source command 


```{r}
getwd() # case sensititve
#setwd("YOUR-DIR")
```

## to list the files in the directory

```{r}
list.files() # lists all files in the directory
```


## Everything is an vector object in R
- Create a series of numbers using command line in R
- Variable names should not contain number, no underscore etc. 
- Don't mix numbers and character in a vector
   - If you mix coercion (un expected outcomes)


```{r}
aa <- 22.7

aa = 1 # DO not use not standard

aa + 2
sqrt(aa+1)
aa/3

ages<-c(1,2,3,4) # another way to create vectors
ages

ages+3   # ages of kids after 3 years 
         # scalar is a zero vector
age
 

```


## Getting help

<code> 
?help 
?hist
</code>

## What happens when you mix variables in a single vector?

x<-c("Brazil","Argentina","India")
x<-c("Brazil",10, "India") 


How to mix the character data and numerical data?

```{r}
Country<-c("USA","Argentina","Mexico")
PerCapitaIncome<-c(  51749,11573, 9749)
Data<-tibble(Country,PerCapitaIncome)
States<-c(50, 23,31)
Data1 <- bind_cols(x = Data, y = tibble(States))  # equivalent to cbind 
```

Let us add a row (equivalent to rbind)

```{r}
Country<-c("India")
PerCapitaIncome<-c(1450)
States<-c(28)
Ndata<-tibble(Country,PerCapitaIncome,States)
FinData<-bind_rows(Data1,Ndata)
```


IndiaSubset<-subset(FinData,Country == "India") 
#Write to a file
write.csv(IndiaSubset,"IndiaSubset.csv")



# what happens; This is called coercing ; Not good. 


new_age<- age+3


# to list all objects created in R up to this point
ls()


# How to input data?


# CSV (most common) but other types can be loaded


read.csv("test.csv")
CSVdat<-read.csv("test.csv")
CSVdat


str(CSVdat)  # str function
summary(CSVdat)


# how to read xls file? 
#????ADD 


# can also read binary files 
# ?readBin 


#What do you do with the data? 


head(CSVdat)
tail(CSVdat)


colnames(CSVdat) 
names(CSVdat)  # same as colnames 
dim(CSVdat)     #dimension of the data
class(CSVdat)
summary(CSVdat)




View(csv-dat) # to edit the data 


# R reads the datta and stores the data as data frames
# Which have the format like matrix 
# To extract or address a variables 
# object[row,column] 


CSVdat[1,2]


CSVdat[ ,2]   # note the levels have already beeb 
                      # populated
CSVdat[2, ]


CSVdat$ID


dim(CSVdat) # dimention 5,3
#Conditional statements
# 
CSVdat$ID[CSVdat$ID>=3] 
subset(CSVdat, ID>=3) # to carve out data with ID>=3


# Concatenation 


#sorting 
CSVdat1<-read.csv("csv-data1.csv")
CSVdat1[order(CSVdat1$ID), ] 
# attach(CSVdat1)
ID 
# what are the problems in attaching?


# sort one column
CSVdat1[order(AGE), ] 


# let us sort by two variables one after another
CSVdat1[order(STATEID,AGE), ]


# why not reverse?
CSVdat1[order(STATEID,-AGE), ]


#data types
INF<-3/0 # Inf or -Inf 
-3/0 


#diff between Inf and NA (not a number) 


!is.na(Inf)


# what is then Inf?
is.finite(INF)
is.infinite(INF)


x<-c(1,2,3,4)
x
length(x) 
min(x)
max(x)


x[1]
x[2:3]


x<-seq(1:10)




# descriptive Stats


summary(data)






#Finally Cleaning up


objects() # what vars do you have in your env


search() #what is attached


#to remove, use rm(object)
detach(dataframe) 






#coercion


x<-seq(1:10)
x
sum(x) # 55
sum(x>5) # 5
#why? coercion
x>5  # logical T or F
         # this will be most cases coerced to numeric 0 or 1 
#  (F F F F F T T T T T)
#  (0 0 0 0 0 1 1 1 1  1) 
# sum them 
sum(x>5) # you get 5 sum of  5 1s 
if you want the sum of their values


sum(x[x>5])


#tapply


#  tapply(X, FactorVar, function) 
tapply(WHO$Over60, WHO$Region, mean)


## Hands-on exercise using Wisconsin Breast Cancer dataset

Now, let us read a slightly complicated Breast Cancer dataset. First let us use
the import data set drop-down option 

![](Images/RS-ImportDataset.png)
![](Images/RS-ImportDataset1.png)
```{r readdata}
#wdbc <- read_csv("C:/Users/Ravi/Desktop/BTEP/Data/wdbc.data", col_names = FALSE)

wdbc <- read_csv("Data/wdbc.data", col_names = FALSE)
#wdbctry2 <- read_csv("C:/Users/Ravi/Desktop/BTEP/Data/wdbc.data", header = FALSE)
names(wdbc)
```

Let us add column names

```{r AssignColnams}
cnames <- c("ID", "Diagnosis", 
            "radius", "Texture", "Perimeter", "area",
            "smoothness", "compactness", "concavity", "concave_points",
            "symmetry","fractaldim",
            "radiusSE", "TextureSE", "PerimeterSE", "areaSE",
            "smoothnessSE", "compactnessSE", "concavitySE", "concave_pointsSE",
            "symmetrySE","fractaldimSE",
            "radiusW", "TextureW", "PerimeterW", "areaW",
            "smoothnessW", "compactnessW", "concavityW", "concave_pointsW",
            "symmetryW","fractaldimW")

names(wdbc) <- cnames
```
 Let us find out how many samples we have in the dataset? 
 
 
```{r}
nrow(wdbc)
```
How many covariates are in the dataset? 
We can look at the Global environment (top right) window to get the information
We can also find that out by typing the following command:
```{r}
ncol(wdbc)
```